sources:
    osm:
        type: TopoJSONTiles
        url:  //vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson?api_key=vector-tiles-VLxfzaw
cameras:
    perspective:
        type: perspective
#        vanishing_point: [0, -500]
        focal_length: [[16, 2], [20, 6]] # pairs of [zoom, focal len]
        vanishing_point: [-250, -250] # relative to center of screen, in pixels
lights:
    directional1:
        type: directional
        direction: [.1, .5, -1]
        diffuse: .7
        ambient: .5
styles:
    buildings:
        base: polygons
        shaders:
            blocks:
                color: |
                    color.rgb *= vec3(min((v_world_position.z*.001 + .5),1.));
    tools:
        animated: true
        shaders:
            extensions: OES_standard_derivatives
            blocks:
                global: |
                    // Common Values
                    //================================
                    float radio = 0.05;
                    vec2 size = vec2(1.,.6);
                    vec3 background = vec3(0.996,0.996,0.918);
                    vec3 midle = vec3(0.824, 0.812, 0.804);
                    vec3 foreground = vec3(0.275,0.298,0.251);

                    // Coord System
                    //================================
                    varying vec3 v_pos;

                    #ifdef TANGRAM_FRAGMENT_SHADER
                    vec2 TileCoords(){return fract(v_pos.xy*0.0002445);}

                    float aastep(float threshold, float value) {
                      #ifdef TANGRAM_EXTENSION_OES_standard_derivatives
                        float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
                        return smoothstep(threshold-afwidth, threshold+afwidth, value);
                      #else
                        return step(threshold, value);
                      #endif
                    }

                    float pulse(float x,float p, float w){
                        x = abs(x - p);
                        if( x>w ) return 0.0;
                        x /= w;
                        return 1.0 - x*x*(3.0-2.0*x);
                    }

                    float boxDF(vec2 st, vec2 size) {
                        float aspect = u_resolution.x/u_resolution.y;
                        st = st*2.-1.;
                        st.x *= aspect;
                        return length(max(abs(st)-size,.0));
                    }

                    float stripes(vec2 st, float width){
                        return aastep(width,abs(sin(st.y*3.14159265358)));
                    }
                    mat2 rotate2d(float angle){
                        return mat2(cos(angle),-sin(angle),
                                    sin(angle),cos(angle));
                    }
                    float stripes(vec2 st){
                        st = rotate2d(.72)*st;
                        st *= 92.;
                        return aastep(.3,abs(sin(st.y*3.14159265358)));
                    }

                    #endif
                position: |
                    v_pos = a_position.xyz * 32767.;
                filter: |
                    vec2 xy = gl_FragCoord.xy/u_resolution.xy;
                    xy.x *= u_resolution.x/u_resolution.y;
                    xy = xy-vec2(.5*u_resolution.x/u_resolution.y,.5);

                    float t = -u_time*.5;
                    float radius = 0.0;
                    // radius = length(xy)*10.;
                    radius = dot(xy,xy)*3.;

                    color.rgb = mix(color.rgb,1.-color.rgb,1.0-aastep(.3,sin(fract(radius+t)*3.1415)));

    border:
        base: lines
        mix: tools
        texcoords: true
        shaders:
            blocks:
                color: |
                    vec2 st = v_texcoord.xy;
                    float pattern = aastep(.5,pulse(st.x,.7,.1)+pulse(st.x,.35,.25));
                    color.rgb = mix(background,color.rgb,pattern);
    b_border:
        base: lines
        mix: tools
        texcoords: true
        shaders:
            blocks:
                color: |
                    vec2 st = v_texcoord.xy;
                    float pattern = aastep(.5,pulse(st.x,.5,.2));
                    color.rgb = mix(background,color.rgb,pattern);

    waves:
        base: polygons
        mix: tools
        shaders:
            blocks:
                color: |
                    vec2 st = (gl_FragCoord.xy / u_resolution.xy);
                    float aspect = u_resolution.x/u_resolution.y;
                    // size.x *= aspect;

                    vec2 pos = st;
                    pos.x = pos.x*aspect;
                    pos.y += sin(pos.x*30.)*.01;
                    color.rgb = mix(color.rgb,background,stripes(pos*200.,.4));
    zigzag:
        base: polygons
        mix: tools
        shaders:
            blocks:
                color: |
                    vec2 st = (gl_FragCoord.xy / u_resolution.xy);
                    float aspect = u_resolution.x/u_resolution.y;
                    // size.x *= aspect;

                    vec2 pos = fract(st*100.);
                    pos.y += mix(fract(pos.x),fract(1.0-pos.x),step(.5,pos.x))*3.;
                    color.rgb = mix(color.rgb,background,stripes(pos,.3));
    hatch:
        base: polygons
        mix: tools
        shaders:
            blocks:
                color: |
                    vec2 st = (gl_FragCoord.xy / u_resolution.xy);
                    float aspect = u_resolution.x/u_resolution.y;
                    // size.x *= aspect;
                    color.rgb = mix(color.rgb,background,stripes(st*3.));
    frame:
        base: polygons
        mix: tools
        shaders:
            blocks:
                color: |
                    vec2 st = (gl_FragCoord.xy / u_resolution.xy);
                    float aspect = u_resolution.x/u_resolution.y;
                    // size.x *= aspect;

                    vec2 pos = st;
                    pos.x = pos.x*aspect;
                    pos.y += sin(pos.x*30.)*.01;
                    color.rgb = mix(color.rgb,background,stripes(pos*200.,.4));

layers:
    water:
        data: { source: osm }
        draw:
            polygons:
                order: 2
                color: '#353535'
            frame:
                order: 1
                color: [1.000, 1.000, 1.000]
            b_border:
                order: 5
                cap: round
                width: 8px
                color: #464C40
                width: 5px
    earth:
        data: { source: osm }
        draw:
            polygons:
                order: 0
                color: '#555'
            waves:
                order: 0
                color: [0.824, 0.812, 0.804]
            border:
                order: 5
                color: #464C40
                cap: round
                width: 8px
    landuse:
        data: { source: osm }
        draw:
            polygons:
                order: 1
                color: '#666'
            hatch:
                order: 2
                color: #464C40
            lines:
                order: 3
                color: white
                cap: round
                width: 2px
    roads:
        data: { source: osm }
        draw:
            lines:
                order: 4
                color: white
                width: [[5, 0.5px],[15, 2px],[85, 50]]
    buildings:
        data: { source: osm }
        draw:
            polygons:
                order: 50
                color: '#999'
            b_border:
                order: 6
                color: [[10,[1,1,1]],[15,[1,1,1]],[18,[0.306, 0.306, 0.306]]]
                width: [[10, 1], [12, 1px],[14, 1px], [16, 2px], [17, 3px], [18, 5px]]
        extruded:
            draw:
                polygons:
                    style: buildings
                    extrude: function () { return feature.height > 0 || $zoom >= 16; }
    road_labels:
        data: { source: osm, layer: roads }
        filter: { name: true, aeroway: false, tunnel: false, railway: false, not: { kind: rail } }

        highway:
            filter: { kind: highway, $zoom: { min: 7 } }
            draw:
                text:
                    font:
                        fill: white
                        typeface: 500 12px Helvetica
        not_highway:
            filter: { not: { kind: highway }, $zoom: { min: 13 } }
            draw:
                text:
                    font:
                        fill: white
                        typeface: 100 11px Helvetica
    places:
        data: { source: osm }
        filter: { name: true }
        draw:
            text:
                font:
                    typeface: Italic 14px Times
                    fill: black
                    stroke: { color: white , width: 5 }
